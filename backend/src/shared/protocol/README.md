# Sample protocol walkthrough

## Background

In the current setup, there are three entities:
1. the client (typically, the user's the web browser)
2. the middleware (a node.js program whose job is to run a web server, do authentication, then
   blindly forward messages back and forth between backend and frontend.
3. The backend. (the C++, indexer, search engine, etc).

## Protocol

1. The client makes the connection to the middleware, does its usual web authentication
   stuff using Google OAuth or whatever.
2. The first message required by the backend is a *Hello* message. This is generated by the
   middleware after a successful login from the frontend. This is the only independent act
   performed by the middleware. After sending the *Hello* message to the backened, it just 
   becomes a blind forwarder of opaque payloads in both directions.
3. The first message sent by the frontend (this will be the *second* message required by the
   backend, after *Hello*) is either *CreateSession* or *AttachSession*.
4. *CreateSession* is used to create a new session with the backend. *AttachSession* is used
   to attach to an existing session (e.g. to smoothly resume an existing session after a
   network interruption).
5. *CreateSession* is not expected to fail. If it does fail, there's nothing for the frontend
   to do other than be sad. However, *AttachSession* might fail, for example if the server has
   been rebooted, the session information will be gone and the client will have to start afresh
   with a new session. So if *AttachSession* fails, the client should reset its state and
   then do *CreateSession*.
6. All subsequent messages between frontend and backend will be *PackagedRequest* and
   *PackagedResponse*. The "packaging" here refers to messages wrapped with serial numbers
   so that the client and server can keep track of unacknowledged messages and resend them
   upon reattaching to a session.
7. A new Session will follow the following pattern.

| Client                           | server          | comments                                                                                                                                                                                             |
|----------------------------------|-----------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Subscribe(query, *undef*)        |                 | Sets up subscription (*undef* means with cursor set to 'end'). Client can show "waiting" until the *AckSubscribe* arrives                                                                            |
|                                  | AckSubscribe    | Server responds with subscription success or failure. This message also includes the initial front and back estimates so the client can know right away whether the query is going to yield anything |
| GetMoreZgrams(20, forBack=false) |                 | Having gotten an estimate for the front and pack, client wants to see up to an additional 20 zgrams in the front. Client can have only one GetMoreZgrams outstanding at a time                       |
|                                  | AckMoreZgrams   | The response to the GetMoreZgrams command. Contains zgrams and updated estimates that the client can use to decide if it wants to send another *GetMoreZgrams*                                       |
|                                  | MetadataUpdate  | New or updated metadata (can arrive any time)                                                                                                                                                        |
|                                  | EstimatesUpdate | Updated estimates (can arrive at any time). A client that is streaming zgrams from the end and currently quiescent, might ask for more zgrams if a new Estimates messages reveals there are now more |
| GetMoreZgrams(3, forBack=true)   |                 | etc.                                                                                                                                                                                                 |

## Server is event-driven

The server is generally event-driven in the sense that it sits around completely idle until
someone tells it to do something.
